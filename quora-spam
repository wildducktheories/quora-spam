#!/bin/bash

set -o pipefail

export QUORA_SPAM_VERSION=v1.8
export QUORA_DOTFILES=${QUORA_DOTFILES:-~/.quora-spam}

die() {
  echo -e "fatal: $*" 1>&2
  exit ${DIE_RC:-1}
}

dispatch () {
  local cmd=$1
  shift 1
  set -- "_$cmd" "$@"
  "$@"
}

_cache() {

  _key() {
    echo "$*" | md5sum | cut -f1 -d' '
  }

  _exec() {
    local key=$(_key "$@")
    if test -f "$cache_dir/$key" && test "$CACHE_BUST" != "true"; then
      cat "$cache_dir/$key"
    else
      out=$("$@")
      local rc=$?
      if test $rc -eq 0; then
        echo "$out" > "$cache_dir/$key"
      fi
      echo "$out"
    fi
  }

  _bust() {
    CACHE_BUST=true _exec "$@"
  }

  cache_dir=$QUORA_DOTFILES/cache
  mkdir -p "$cache_dir"

  dispatch "$@"
}

_credentials() {
  if test -z "$QUORA_CREDENTIALS"; then
    export QUORA_CREDENTIALS=$(test -f "$QUORA_DOTFILES/credentials" && cat "$QUORA_DOTFILES/credentials")
  fi
  echo "$QUORA_CREDENTIALS"
}

_submit-credentials() {
  if test -f "${QUORA_DOTFILES}/submit-credentials"; then
    cat "${QUORA_DOTFILES}/submit-credentials"
  else
    _credentials
  fi
}

_config() {
  _require dotfiles

  _get() {
    local key=$1
    jq -r --arg key "$key" '.[$key]' < ${QUORA_DOTFILES}/config
  }

  _set() {
    local update
    update=$(_ju o "$@") || die "usage: config set: key:value"
    jq -s ".[0]*$update" \
      < "${QUORA_DOTFILES}/config" \
      > "${QUORA_DOTFILES}/config.new" &&
    mv "${QUORA_DOTFILES}/config.new" "${QUORA_DOTFILES}/config"
  }

  _() {
    jq . "${QUORA_DOTFILES}/config"
  }

  dispatch "$@"
}

_curl() {
  local o="$(_ju o "$@")"

  local debug=$(if test -n "$CURL_DEBUG"; then echo true; else echo false; fi)

  local credentials=$(_credentials)
  test -n "$credentials" || die "not logged in"

  headers=${headers:-{\}}

  local host method path data headers args

  eval "$(echo "$o" | _ju pipe 'select host,method,path,data,headers,args|to local')"

  case "$method" in
    (GET)
      credentials="$(jq -nc "$credentials"'|with_entries(select(.key=="cookie"))')"
    ;;
    (POST|"")
      :
    ;;
    (*)
      set -- "$@" -X$method
    ;;
  esac

  local sensitive_headers=$(jq -nc "${headers}*${credentials}")

  if $debug && test -n "$data"; then
    : #echo "$data" | jq -c '["DEBUG", .]' 1>&2
  fi

  (
    IFS=$'\t'
    set -- \
      --compressed \
      -s \
      $(
        (
          echo "$args";
          echo "$sensitive_headers";
        ) | __to curl-args
      )
    if test -n "$data"; then
      set -- "$@" --data-raw "$data"
    fi
    host=${host:-www.quora.com}

    if (true >&3) 2>/dev/null; then
      local output=$(mktemp)
      local diagnostics=$(mktemp)
      local verbose=$(mktemp)
      trap "rm -f \"$output\" \"$diagnostics\" \"$verbose\"" exit

      set -- "$@" -v -o "$output" -w '%{stdout}%{json}' "https://$host$path"

      curl "$@" >"${diagnostics}" 2>"${verbose}"

      local rc=$?

      cat "$output"
      if test -n "$CURL_DEBUG"; then
        cat "$verbose" 1>&2
      fi

      if ! response_body="$(jq -c . "$output" 2>/dev/null)"; then
        response_body="$(jq -sR . $output)"
      fi

      response_headers="$(
        cat "$verbose" \
        | _from curl-response-headers \
        | _filter headers-as-map \
        | jq -c .
      )"

      test $rc -eq 0 || die "curl: non-zero exit code: $rc"

      _ju o \
        "agent:$(
          _ju o \
            "args:$args" \
            "diagnostics:$(jq -c . <$diagnostics)" \
            "verbose:$(jq -sR . <$verbose)" \
            | jq -c 'with_entries(if .value=="" then empty else . end)'
        )" \
        "request:$(
          _ju o "host:$host" \
            "method:$method" \
            "path:$path" \
            "headers:$headers" \
            "body:$data" \
            "elided-headers:$(jq -nc "${credentials}|keys")" \
            | jq -c 'with_entries(if .value=="" then empty else . end)'

        )" \
        "response:$(
          _ju o \
            "body:$response_body" \
            "headers:$response_headers"
        )" \
        | jq . 1>&3

      eval "$(jq -c . < "${diagnostics}" | _ju pipe 'select http_code|to env')"
      case "$http_code" in
        (2*|3*)
          return 0
        ;;
        (4*|5*)
          jq -c . < "${diagnostics}" >&2
          DIE_RC=4 die "curl: request failed with http_code: $http_code"
        ;;
        (5*)
          jq -c . < "${diagnostics}" >&2
          DIE_RC=5 die "curl: server failed with http_code: $http_code"
        ;;
      esac
    else
      curl "$@" "https://$host$path" || die "curl: failed: $?"
    fi
  )||exit $?
}

_file-profile-report() {
  local profile=${1#/profile/}

  local is_enabled=$(_config get enable-submit)

  if test "$is_enabled" = "true"; then
    local uid=$(_query uid $profile)
    test -n "$uid" || die "file-profile-report: usage: ... {profileUrl}"

    title="profile: ($profile, $uid)"
    activity="$(quora-spam query activity-summary $uid)"
    others="$(quora-spam query sweet-hot-girls \
          | jq \
              -sc \
              --arg 'profile' "$profile" \
            'map(.profileUrl|select(.|contains($profile)|not))')"

    data="$(_ju o "activity:$activity" "title:$title" "others:$others" | _explode exec --stdin body mutation_post_add_legacy)"
    headers=$(_explode exec headers mutation_post_add_legacy)
    host=$(_explode exec host mutation_post_add_legacy)
    path=$(_explode exec path mutation_post_add_legacy)
    (
      QUORA_CREDENTIALS=$(_submit-credentials) _curl \
        data:"$data" \
        headers:"$headers" \
        host:$host \
        method:POST \
        path:"$path" \
        >/dev/null

      _ju o uid:$uid
   )
  else
    echo "warn: profile report not submitted. run 'quora-spam config set enable-submit:true' to enable" 1>&2
  fi
}

_filter() {

  _simple-activity() {
    local bias=${1:--1}
    jq --argjson bias "$bias" '
      [.data.user.activityConnection.edges[].node as $node
      |$node.feedReason
      |select(.__isFeedReason=="UserUpvotedAnswerReason")
      |.uid=.userNames[0].uid
      |.timestamp|=(./1000000|round|todateiso8601)
      |.profileUrl=.userNames[0].profileUrl
      |.text=($node.answer.question.title|fromjson|.sections[]|.spans[0].text)][$bias]
    ' \
    | _ju select 'uid,url,text,timestamp,profileUrl'
  }

  _busy-profiles() {
    (
      set -e
      while read -r profile; do
        eval "$(echo "$profile" | _ju pipe 'select uid|to env')"
        _cache exec _query activity-summary "$uid" | jq -sc "$profile*(.[0]|{\"activity_summary\": .})" || die "busy-profiles: activity-summary: failed"
      done | jq -c --argjson "limit" "${limit:-10}" 'select(.activity_summary.upvotes.rate_per_hour>$limit)|.isBusy=true'
    ) || die "busy-profiles: failed"
  }

  _headers-as-map() {
    jq '
      reduce .[] as $o (
        {};
        .[$o.key]|=(
          if
            . == null
          then
            [$o.value]
          else
            .+[$o.value]
          end
        )
      )|with_entries(
        if
          (.value|length) == 1
        then
          .value|=.[0]
        else
          .
        end
      )
    '
  }

  _html() {
    grep "window.ansFrontendGlobals.data.inlineQueryResults.results" \
    | tail -1 \
    | sed "s/;\$//" \
    | sed "s/^[^=]*= //" \
    | jq -r .
  }

  _jqc() {
    # strip leading, trailing whitespace,
    # delete empty lines
    # join lines not separateed by trailing ;

    if test -z "$JQC"; then
      tr \\011 ' ' | sed 's/^ *//;s/ *$//g;s/ *; *$/;/;/^$/d;' | awk '!/;$/{printf $0}/;$/'
    else
      ${JQC}
    fi
  }

  _simple-notifications() {
    jq -c '
        .data.viewer.sentNotifCollectionsConnection.edges[].node
        |{
            "sncid": .sncid,
            "uid": (.responsibleUser.uid|tostring),
            "profileUrl": .userImageUser.profileUrl,
            "isSpam": false,
            "isRead": .isRead
        }'
  }

  _simple-profiles() {
    jq -c . \
    | while read profile; do
        eval "$(echo "$profile" | _ju pipe 'select profileUrl|to env')"
        jq -cs ".[0]*.[1]" <(echo "$profile") <(_query simple-profile "$profileUrl");
    done
  }

  # converts a full profile into a simple profile
  _full-to-simple-profile() {
    jq -c '{
      "uid": .data.user.uid,
      "profileUrl":.data.user.profileUrl,
      "isBlockedByViewer": .data.user.isBlockedByViewer,
      "viewerHasMuted": .data.user.viewerHasMuted,
      "isUserBanned": .data.user.isUserBanned,
      "followingCount": .data.user.followingCount,
      "followerCount": .data.user.followingCount,
      "creationTime": .data.user.creationTime,
      "profileAge": (((((now|round) - (.data.user.creationTime/1000000))/8640)|round)/10),
      "isSpam": false,
      "links": [
          .data.user.descriptionQtextDocument.legacyJson.sections[].spans[]
          |select(.modifiers.link!=null)
          |{"text":.text, "url":.modifiers.link.url}
       ],
      "space_links": [
          .data.user.combinedProfileFeedConnection.edges[]
          |.node.post.contentQtextDocument.legacyJson
          |(
            if . then (
              fromjson
              |.sections[]
              |.spans[]
              |.modifiers.embed.url
              |select(. and startswith("https://adultdating.quora.com"))
            ) else
              empty
            end
          )
      ]
    }|.isSpammyUrl=(
        .links
        |any(
             (  .text as $text
                |(
                    (.url|startswith("http"))
                    and (.url|startswith("https://www.quora.com")|not)
                    and (.url|contains($text)|not)
                )
             )
        )
    )'
  }

  _sweet-hot-girls() {
    jq -c 'select(
      .links
      |any(
        (.text|startswith("sweethot"))
        or (.text|contains("hotgirls"))
        or (.text|startswith("hot"))
        or (.url|contains("applycisra.com"))
      )
    )|.isSpam=true'
  }

  dispatch "$@"
}

__from() {
  _curl-response-headers() {
    (
      echo -e "key\tvalue";
      tr -d \\015 \
      | grep "^<" \
      | sed -n "2,\$p" \
      | sed "s/^< //;s/^\([^:]*\): \(.*\)/\1\t\2/" \
      | sed "/^HTTP/d" \
      | sed "/^\$/d" \
    ) \
    | _ju from tsv \
    | jq -sc .
  }

  dispatch "$@"
}

_from() {
  __from "$@"
}

_har() {

  _credentials() {
    _raw-headers | \
    jq -c '
      [to_entries[]
      |.value
      |with_entries(
        select(
          .key=="cookie"
          or .key=="quora-formkey"
        )
      )][-1]
    '
  }

  _raw-headers() {
    jq '
      [
        .log.entries[].request
        |select(.url|contains("quora.com/"))
        |
          [.headers[]|.key=.name]
          |from_entries
          |.[":path"] as $path
          |select($path != null) as $headers
        |{
            "key": $path,
            "value": $headers
        }
      ]
      |from_entries'
  }

  _headers() {
    _raw-headers | \
    jq '
      with_entries(
        .value
        |=with_entries(
          if
            (.key|startswith(":"))
            or (.key=="content-length")
            or (.key=="referer")
            or (.key=="cookie")
            or (.key=="quora-formkey")
          then
            empty
          else
            .
          end
        )
      )'
  }

  _bodies() {
    jq '
      [
        .log.entries[].request
        |select(.url|contains("quora.com/"))
        |([.headers[]|.key=.name]|from_entries) as $headers
        |$headers[":path"] as $path
        |select($path!=null)
        |select($path|ascii_downcase|contains("facebook")|not)
        |select(.postData.mimeType=="application/json")
        |(.postData.text|fromjson) as $body
        |{
            "key": $path,
            "value": $body
        }
      ]
      |from_entries'
  }

  _save() {
    local selector=$1
    (
      umask 077
      _require dotfiles
      case "$selector" in
        (submit-credentials)
            _credentials > $QUORA_DOTFILES/submit-credentials
        ;;
        ("")
          (
            cat > ${QUORA_DOTFILES}/har &&
            _headers< $QUORA_DOTFILES/har > $QUORA_DOTFILES/headers &&
            _bodies < $QUORA_DOTFILES/har > $QUORA_DOTFILES/bodies &&
            _credentials < $QUORA_DOTFILES/har > $QUORA_DOTFILES/credentials
          )
        ;;
      esac
    ) || exit $?
  }

  dispatch "$@"
}

_help() {
  grep "^ *_[^ ]*(" quora-spam | tr -d '(){' | sed "s/ *\$//" | sed 's/\( *\)_/\1/'
}

_install() {
  pre_reqs="jq curl make docker"
  _Darwin() {
    set --
    for c in $pre_reqs; do
      if !command -v $c >/dev/null 2>&1; then
        set -- "$@" "$c"
      fi
    done
    if test $# -gt 0; then
      brew install "$@"
    fi
  }

  _default() {
    _pre-reqs() {
      rc=0
      for c in $pre_reqs; do
        if ! command -v "$c" >/dev/null 2>&1; then
          echo "please install $c" 1>&2
        fi
      done
      test $rc -eq 0 || die "some pre-requisites missing"
    }
  }

  if test -z "$1"; then
    set -- "pre-reqs" "$@"
  fi

  cmd=$(uname)
  if test "$(type -t _$cmd)" != "function"; then
    cmd=default
  fi
  dispatch "$cmd" "$@"
}

_login() {
  local selector=$1
  case "$selector" in
    (submit)
      local credentials=$(_submit-credentials)
      if test -z "$credentials"; then
        die "not logged in\n\nrun:\n\n  'pbpaste | $(basename ${BASH_SOURCE[0]}) har save submit-credentials'\n\nor:\n\n  '$(basename ${BASH_SOURCE[0]}) har save submit-credentials < saved.har'\n\nwith the contents of a web browser HAR file to extract credentials.\n" 1>&2
      fi
    ;;
    ("")
      local credentials=$(_credentials)
      if test -z "$credentials"; then
        die "not logged in\n\nrun:\n\n  'pbpaste | $(basename ${BASH_SOURCE[0]}) har save'\n\nor:\n\n  '$(basename ${BASH_SOURCE[0]}) har save < saved.har'\n\nwith the contents of a web browser HAR file to extract credentials.\n" 1>&2
      fi
    ;;
  esac
  echo "starting quora-spam (qs) shell. exit to logout" 1>&2
  (_shell)
  local rc=$?
  _logout $selector
  echo "logged out." 1>&2
  return $rc
}

_logout() {
  local selector=$1
  if test -d ${QUORA_DOTFILES}; then
    case "$selector" in
      (submit)
          rm -f "${QUORA_DOTFILES}/submit-credentials"
      ;;
      ("")
          rm -f "${QUORA_DOTFILES}/credentials"
          rm -f "${QUORA_DOTFILES}/har"
          rm -f "${QUORA_DOTFILES}/headers"
          rm -f "${QUORA_DOTFILES}/bodies"
          rm -f "${QUORA_DOTFILES}/self"
      ;;
    esac
  fi
}

_loop() {
  LOOP_DELAY=${LOOP_DELAY:-900}
  while true; do
    echo "$(date)...processing..." 1>&2
    dispatch "$@"
    echo -n "$(date)...sleeping..." 1>&2
    sleep $LOOP_DELAY
    echo "" 1>&2
  done
}


_ju() {

  _a() {
    _array "$@"
  }

  _array() {
    while test $# -gt 0; do
      echo "$1"
      shift
    done | _jsonify | jq -sc .
  }

  _from() {
    _keys() {
      local default=${1:-null}
      jq -Rsc --argjson default "$default" '
        rtrimstr("\n")
        |split("\n")
        |[
          .[]|{"key": ., "value": $default}
         ]
        |from_entries'
    }

    dispatch "$@"
  }

  _func() {
    _jsonify()
    {
       echo 'def jsonify: . as $in|try fromjson catch $in;'
    }

    _escape() {
      echo 'def escape: if type == "string" and contains("\n") then tojson else tostring end;'
    }

    dispatch "$@"
  }

  _from() {

    _keys() {
      local default=${1:-null}
      jq -Rsc --argjson default "$default" '
        rtrimstr("\n")
        |split("\n")
        |[
          .[]|{"key": ., "value": $default}
         ]
        |from_entries'
    }

    _ktv() {
      jq -Rc 'split("\t")' \
      | _from unblocked '.next|length==0' '[]' \
      | jq -c "$(_func jsonify)"'
        map(
          map(jsonify)
          |(.[0]|=tostring)
          |{"key":.[0], "value":.[1]}
        )
        |from_entries'
    }

    _tsv() {
      jq -Rsc \
        "$(_func jsonify)"'
         rtrimstr("\n")
         |split("\n")
         |map(split("\t"))
         |.[0] as $header
         |.[1:] as $data
         |$data[]
         |. as $in
         |[
            foreach $header[] as $k
            (0; .+1; {"key": $k, "value": ($in[.-1]|jsonify)})
          ]
         |from_entries'
    }

    _unblocked() {
      local eob=$1
      local eob_value=${2:-null}

      jq -c --argjson eob_value "$eob_value" "def eob: $eob;"'
        {"next": ., "output": []}
        |until(
          eob;
          .output=(.output+[.next])
          |.next=try input catch $eob_value
        )|.output
      '

    }

    dispatch "$@"
  }

  _jsonify() {
     sed 's/^ *//;s/ *\$//' | jq -Rc "$(_func jsonify) jsonify"
  }

  _object() {
    DEFAULT=$(
      while test $# -gt 0; do
        local key_value=$1
        shift
        if test "$key_value" = --; then
          echo "$1"
          return
        fi
      done | _jsonify
    )

    escape() {
      local v="$1"
      if test "${v/$'\n'}" != "$v"; then
        v=$(echo -n "$v" | jq -Rs .)
      fi
      echo "$v"
    }

    local tab=$'\t'

    (while test $# -gt 0; do
      local key_value="$1"
      shift
      if test "$key_value" = --; then
        break
      fi
      key=${key_value%%:*}
      if test "$key" = "$key_value"; then
        value=null
      else
        value=${key_value#*:}
      fi
      echo "$(escape "$key")${tab}$(escape "$value")"
    done; echo "") | _from ktv | jq -c --argjson default "${DEFAULT:-null}" 'with_entries(if .value == null then .value=$default else . end)'
  }

  _o() {
    _object "$@"
  }

  _pipe() {
    local pipe=$1
    pipe=$(echo "$pipe" | sed "s/^ */_/;s/| */|_/g")
    eval "$pipe"
  }

  _select() {
    local selector=$1
    local map=$(jq -nr "$(_selector "$selector")|.[]" | _from keys "$default")
    jq -c --argjson map "$map" '[to_entries[]|select(.key|in($map))]|from_entries'
  }

  _selector() {
    local selector=$1
    if test "${selector#[}" != "$selector"; then
      echo "$selector" | _jsonify | jq -c .
    else
      (
        IFS=,;
        set -- $selector
        while test $# -gt 0; do
          echo "$1"
          shift
        done | _jsonify | jq -sc .
      )
    fi
  }

  _to() {
    _env() {
      jq -r 'to_entries|map(.key+"="+(
        if .value == null then
          ""
        elif (.value|type|(. == "object") or (. == "array"))
        then
          "'\''"+(.value|tojson)+"'\''"
        else
          .value|tojson
        end
        )+";"
      )[]'
    }

    _local() {
      _env | sed "s/^/local /";
    }

    _keys() {
        jq -cr 'select(type == "object")|[to_entries[].key|tostring]|join("\t")'
    }

    dispatch "$@"
  }

  dispatch "$@"
}

_post() {
  _activity() {
    eval "$(jq -s '.[0]*.[1]' <(_ju o first:1 after:998) <(_ju o "$@") | _ju pipe 'select uid,first,after|to env')"
    test -n "$uid" && test -n "$first" && test -n "$after" || die "usage: activity uid:{uid} first:{first} after:{after}"

    local data="$(
      _ju o "after:$after" "first:$first" "uid:$uid" \
      | _explode exec --stdin body query_activity
    )"

    _curl \
      data:"$data" \
      headers:"$(_explode exec headers query_activity)" \
      method:POST \
      path:"$(_explode exec path query_activity)"
  }

  _shares() {
    eval "$(jq -s '.[0]*.[1]' <(_ju o first:10 after:0) <(_ju o "$@") | _ju pipe 'select nodeId,first,after|to env')"
    test -n "$nodeId" && test -n "$first" && test -n "$after" || die "usage: shares nodeId:{nodeId} first:{first} after:{after}"

    local data="$(
      _ju o "after:$after" "first:$first" "nodeId:$nodeId" \
      | _explode exec --stdin body query_shares
    )"

    _curl \
      data:"$data" \
      headers:"$(_explode exec headers query_shares)" \
      method:POST \
      path:"$(_explode exec path query_shares)"
  }

  _mute() {
    local uid=$1

    test -n "$uid" || die "usage: post mute {uid}"

    _curl \
      method:POST \
      path:"$(_explode exec path mutation_user_mute)" \
      headers:"$(_explode exec headers mutation_user_mute)" \
      data:"$(_ju o uid:$uid | _explode exec --stdin body mutation_user_mute)" \
      | jq -c --arg uid "$uid" '
            {
                "uid": $uid,
                "viewerHasMuted": .data.userMute.user.viewerHasMuted
            }'
  }

  _block() {
    local uid=$1

    test -n "$uid" || die "usage: post mute {uid}"

    _curl \
      method:POST \
      path:"$(_explode exec path mutation_user_block)" \
      headers:"$(_explode exec headers mutation_user_block)" \
      data:"$(_ju o uid:$uid | _explode exec --stdin body mutation_user_block)" \
      | jq -c --arg uid "$uid" '
            {
                "uid": $uid,
                "isBlockedByViewer": .data.userSetBlock.targetUser.isBlockedByViewer
            }'
  }

  _markAsRead() {
    local sncid="$1"

    test -n "$sncid" || die "usage: post markAsRead {sncid}"
    _curl \
      method:POST \
      path:"$(_explode exec path mutation_notification_markAsRead)" \
      headers:"$(_explode exec headers mutation_notification_markAsRead)" \
      data:"$(_ju o sncid:$sncid | _explode exec --stdin body mutation_notification_markAsRead)" \
      | jq -c --argjson sncid "$sncid" '
      {
          "sncid": $sncid,
          "isRead": (.data.markSentNotifCollectionAsRead.sentNotifCollection.isRead//false)
      }'

  }

  _queue-post() {
    (
      HOST=profilereports.quora.com
      QUORA_CREDENTIALS=$(_submit-credentials)
      _curl \
        "method:POST" \
        "host:$HOST" \
        "path:$(_explode exec path mutation_post_add)" \
        "headers:$(_explode exec headers mutation_post_add)" \
        "data:$(_explode exec --stdin body mutation_post_add)"
    ) || exit $?
  }

  _report() {
    local data=$(jq -s '.[0]*.[1]' <(_ju o message:"Spammy link in profile.") <(_ju o "$@")  | _explode exec --stdin body mutation_report_add)
    _curl \
      method:POST \
      path:"$(_explode exec path mutation_report_add)" \
      headers:"$(_explode exec headers mutation_report_add)" \
      data:"$data" \
      | jq -c --arg uid "$uid" '{
           "uid": $uid,
           "isBlockedByViewer": .data.reportAdd.reportable.isBlockedByViewer
      }'
  }

  dispatch "$@"
}

_process() {
  local selector=$1

  test -n "$selector" || die "process {selector}"

  _explode-adult-dating() {
    _query explode-adult-dating | while read profile; do
      eval "$(echo "$profile" | _ju pipe 'select uid,isBlockedByViewer,profileUrl,activity_summary|to env')"
      if test "$isBlockedByViewer" = "false"; then
        _post block $uid
        CACHE_BUST=true _query simple-profile $profileUrl | jq -sc "$profile*(.[0]|del(.isSpam))"
      fi
    done
  }

  if test "$(type -t "_$selector")" = "function"; then
    dispatch "$@"
  else
    _query "$selector" | _report "$selector"
  fi
}

_query() {

  _activity-summary() {

    local uid=$1
    #echo "activity-summary: uid=$uid" 1>&2
    (
      set -e
      test -n "$uid" || die "usage: activity-summary {uid}"

      while true; do
        count=$(_post activity uid:$uid first:1 after:998 | jq -r '.data.user.activityConnection.pageInfo.endCursor//0') || die "query: activity-summary: count failed"
        count=${count:-0}
        if test "${count:-0}" -gt 10; then
          first=$(_post activity uid:$uid first:10 after:$(expr $count - 10) | _filter simple-activity) || die "query: activity-summary: first failed: uid:$uid"
          last=$(_post activity uid:$uid first:10 after:0 | _filter simple-activity 0) || die "query: activity-summary: last failed: uid:$uid first:1 after:0"
        else
          count=0
          first=null
          last=null
          break
        fi
        if test -n "$first" -a -n "$last"; then
          break
        fi
      done

      jq -nc \
        --argjson count "${count:0}" \
        --argjson first "${first}" \
        --argjson last "${last}" \
        --argjson uid "$uid" '
      (if $count > 0 then (($last.timestamp|fromdateiso8601)-($first.timestamp|fromdateiso8601)) else 0 end) as $active
      |(if $count > 0 then ($count*36000/$active|round|./10) else 0 end) as $rate
      |{
          uid: $uid,
          profileUrl: $first.profileUrl,

          upvotes: {
            count: $count,
            active_seconds: $active,
            active_hours: ($active/360|round|./10),
            rate_per_hour: $rate,
            first: ($first|del(.uid)|del(.profileUrl)),
            last: ($last|del(.uid)|del(.profileUrl))
          }|(if (.first) then . else del(.first) end)
           |(if (.last) then . else del(.last) end)
      }
      |if (.profileUrl) then . else del(.profileUrl) end
      '
    ) || die "activity-summary failed for uid=$uid"
  }

  _adult-dating() {
    _simple-profiles | jq -c 'select(((.space_links//[])|length) > 0)|.isSpam=true'
  }

  _busy-profiles() {
    _query simple-profiles | _filter busy-profiles
  }

  _explode-adult-dating() {
    (
      _query adult-dating \
      | jq -r .space_links[] \
      | sort \
      | uniq \
      | while read url; do _query simple-shares "$url"; done \
      | jq -r .profiles[] \
      | while read profileUrl; do _query simple-profile "$profileUrl"; done \
      | while read profile; do
        local uid=$(echo "$profile" | jq -r ".uid")
        if test -n "$uid"; then
          _cache exec _query activity-summary "$uid" | jq -cs "$profile*.[0]";
        fi
      done
    )
  }

  _simple-space-page() {
    local url=$1

    eval "$(jq --arg url "$url" -n '
      $url
      |[.|match("https://([^/]*)(/.*)")|.captures[].string
      ]
      |{"host": .[0], "path":.[1]}
    ' | _ju to env)"

    _cache exec _curl \
      method:GET \
      host:$host \
      path:$path | _filter html | jq --arg url "$url" '{"nodeId": .data.tribeItem.post.id, "url": $url}'
  }

  _simple-shares() {
    local url=$1

    page="$(_simple-space-page "$url")"
    eval "$(echo "$page" | _ju pipe 'select nodeId|to env')"
    local profiles=$(
      let after=-1
      let stride=10
      while true; do
        out=$(
          _cache exec _post shares "nodeId:$nodeId" "first:$stride" "after:$after" \
          | jq -r '.data.node.sharePostsConnection.edges[].node.author.profileUrl'
        )
        test -z "$out" && break
        echo "$out"
        let after=after+stride
      done | jq -R . | jq -sc .
    )
    jq -nc --argjson page "$page" --argjson profiles "$profiles" '$page|.profiles=$profiles'
  }

  _nodeId() {
    local url=$1
    curl -s "$url" | _filter html | jq -r .data.tribeItem.post.id
  }

  _profile() {
    local profile=${1#/profile/}
    _curl \
      args:'["-L"]' \
      method:GET \
      "headers:$(_explode exec headers profile)" \
      "path:$(ju o profileUrl:"$profile" | _explode exec --stdin path profile)" \
      | _filter html \
      | jq '
        select(.data.user)
        |(
          if .data.user.descriptionQtextDocument.legacyJson then
            .data.user.descriptionQtextDocument.legacyJson|=fromjson
          else
            .
          end
        )'
  }

  _simple-notifications() {
    _upvotes | _filter simple-notifications
  }

  _simple-profile()  {
    local profile=${1#/profile/}
    _cache exec _profile "$profile" | _filter full-to-simple-profile
  }

  _self() {
    _profile | _filter full-to-simple-profile
  }

  _simple-profiles() {
    _simple-notifications | _filter simple-profiles
  }

  _sweet-hot-girls() {
    _simple-profiles | _filter sweet-hot-girls
  }

  _uid() {
    local profile=${1#/profile/}
    _simple-profile "$profile" | jq -r .uid
  }

  _upvotes() {
    _curl \
      method:GET \
      "path:$(_explode exec path upvotes)" \
      "headers:$(_explode exec headers upvotes)" \
    | _filter html
  }

  _young-profiles() {
    _query simple-profiles | jq -c 'select(.profileAge < 7)|.isYoung=true'
  }

  dispatch "$@"
}

_require() {
  _dotfiles() {
    if ! test -d "${QUORA_DOTFILES}"; then
      mkdir -p "${QUORA_DOTFILES}"
      chmod 2700 "${QUORA_DOTFILES}"
    fi
    if ! test -f "${QUORA_DOTFILES}/config"; then
      echo '{
        "enable-submit": false
      }' > "${QUORA_DOTFILES}/config"
    fi
  }

  dispatch "$@"
}

_report() {
  _sweet-hot-girls() {
    while read -r profile; do
      (
        eval "$(echo "$profile" | _ju pipe 'select uid,isBlockedByViewer,viewerHasMuted,isRead,sncid,profileUrl|to env')"
        if test "$isBlockedByViewer+$viewerHasMuted+$isRead" = "true+true+true"; then
          continue
        fi
        echo "$profile"
        if test "$isRead" = "false"; then
          _post markAsRead "$sncid"
        fi
        if test "$isBlockedByViewer" = "false"; then
          _post report "uid:$uid" "message:Spammy upvote from profile with deceptive sweethotgirls/hotsweetgirls link (sncid:$sncid)" | jq -c .;
          _file-profile-report "$profileUrl"
        fi
        if test "$viewerHasMuted" = "false"; then
          _post mute "$uid"
        fi
        CACHE_BUST=true _query simple-profile $profileUrl | jq -c 'del(.isSpam)'
      ) | jq -cs "select(.[0] != null)|.[0]*(.[1]//{})*(.[2]//{})*(.[3]//{})"
      sleep 5;
    done
 }

 _adult-dating() {
    while read -r profile; do
      (
        eval "$(echo "$profile" | _ju pipe 'select uid,isBlockedByViewer,viewerHasMuted,isRead,sncid,profileUrl|to env')"
        if test "$isBlockedByViewer+$viewerHasMuted+$isRead" = "true+true+true"; then
          continue
        fi
        echo "$profile"
        if test "$isRead" = "false"; then
          _post markAsRead "$sncid"
        fi
        if test "$isBlockedByViewer" = "false"; then
          _post report "uid:$uid" "message:This profile is generating upvote spam at between 20-60 upvotes per hour intended to drive viewers to visit adultdating.quora.com." | jq -c .;
        fi
        if test "$viewerHasMuted" = "false"; then
          _post mute "$uid"
        fi
        CACHE_BUST=true _query simple-profile $profileUrl | jq -c 'del(.isSpam)'
      ) | jq -cs "select(.[0] != null)|.[0]*(.[1]//{})*(.[2]//{})*(.[3]//{})"
      sleep 5;
    done
 }

 jq -c 'select(.isSpam)' | dispatch "$@"
}

_shell() {
  export PS1="\h:\W \u (qs)\$ "
  ${SHELL:-bash}
}

_explodeable() {

  _requires() {
    echo '{"path":[],"body":[],"headers":[]}'
  }

  _body() {
    echo "empty"
  }

  _host() {
    jq -nc --arg "host" "${HOST:-www.quora.com}" '$host'
  }

  _path() {
    echo '""'
  }

  _headers() {
    echo "{}"
  }

  _templates() {
    _accept() {
      _headers() {
        jq -nc '{
          "accept": "*/*",
          "accept-encoding": "gzip, deflate, br",
          "accept-language": "en-AU,en;q=0.9,en-US;q=0.8"
        }'
      }
      dispatch "$@"
    }

    _sec_ch_ua() {
      _headers() {
        jq -nc '{
          "sec-ch-ua": "\".Not/A)Brand\";v=\"99\", \"Google Chrome\";v=\"103\", \"Chromium\";v=\"103\"",
          "sec-ch-ua-mobile": "?0",
          "sec-ch-ua-platform": "\"macOS\"",
        }'
      }
      dispatch "$@"
    }

    _origin() {
      _headers() {
        jq -nc --arg host "${HOST:-www.quora.com}" '{"origin": "https://\($host)"}'
      }
      dispatch "$@"
    }

    _origin_profile_reports() {
      _headers() {
        echo '{"origin": "https://profilereports.quora.com"}'
      }
      dispatch "$@"
    }

    _content_type_json() {
      _headers() {
        echo '{"content-type": "application/json"}'
      }
      dispatch "$@"
    }

    _cache_control_max_age_0() {
      echo '{"cache-control": "max-age=0"}'
    }

    _sec_fetch_document_navigate_same_origin() {
      echo '
        {
          "sec-fetch-dest": "document",
          "sec-fetch-mode": "navigate",
          "sec-fetch-site": "same-origin"
        }
      '
    }

    _sec_fetch_empty_cors_same_origin() {
      _headers() {
        jq -nc '{
          "sec-fetch-dest": "empty",
          "sec-fetch-mode": "cors",
          "sec-fetch-site": "same-origin",
          "sec-fetch-user": "?1",
        }'
      }
      dispatch "$@"
    }

    _upgrade_insecure_requests() {
      _headers() {
        echo '{"upgrade-insecure-requests": "1"}'
      }

      dispatch "$@"
    }

    _user_agent() {
      _headers() {
        echo '{"user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36"}'
      }
      dispatch "$@"
    }

    _lib() {
      _requires() {
        jq -nc '{
          "headers": [
            "accept",
            "cache_control_max_age_0",
            "content_type_json",
            "origin",
            "origin_profile_reports",
            "sec_ch_ua",
            "sec_fetch_document_navigate_same_origin",
            "sec_fetch_empty_cors_same_origin",
            "upgrade_insecure_requests",
            "user_agent"
          ]
        }'
      }

      _headers() {
        echo '
          .;
          def quora(ch;w;s;r):
            {
              "quora-broadcast-id": (ch+"-"+w+"-"+s),
              "quora-canary-revision": "false",
              "quora-revision": r,
              "quora-window-id": w
            }
        '
      }

      dispatch "$@"
    }

    _mutation_notification_markAsRead() {
      _body() {
        echo '{
          "queryName":"NotifItem_markSentNotifCollectionAsRead_Mutation",
          "extensions":{
            "hash":"9eda4e6d8e46ff1d241f1d4af22bfe664152265aa9693e57d67b9721a32d11bf"
          },
          "variables":{
            "sncid":.sncid,
            "source":"notif_page",
            "shouldLogClick":true
          }
        }'
      }

      _headers() {
        echo '
          accept
          *content_type_json
          *origin
          *quora("main-w-chan49-8888";"react_pxemluvapjrirdhr";"UQaz";"b9c9c3eca0656a91bd2c1aa588dcc28495fe1684")
          *sec_ch_ua
          *sec_fetch_empty_cors_same_origin
          *user_agent
        '
      }

      _path() {
        echo '"/graphql/gql_POST?q=NotifItem_markSentNotifCollectionAsRead_Mutation"'
      }

      _requires() {
        echo '{"headers":["lib"]}'
      }

      dispatch "$@"
    }

    _mutation_post_add_legacy() {

      _body() {
        echo '
          {
            "queryName": "UniversalComposerModalWrapper_postAdd_Mutation",
            "extensions": {
              "hash": "7d9cf9a9e5bb12d37a02fe1ec7cd983198467d2c75ec61e304024f1ce4f6840b"
            },
            "variables": {
              "tribeId": (.tribeId//2841204),
              "title": {
                "sections": [
                  {
                    "type": "plain",
                    "spans": [
                      {
                        "text": .title,
                        "modifiers": {}
                      }
                    ],
                    "indent": 0,
                    "is_rtl": false,
                    "quoted": false
                  }
                ]
              }|tojson,
              "content": (profile_report_contents|tojson),
              "shouldQueue": (.shouldQueue//true),
              "accessOption": null,
              "credentialId": null
            }
          }
        '
      }

      _headers() {
        echo '
          accept
          *content_type_json
          *origin_profile_reports
          *quora("main-w-chan49-8888";"react_eutcerodozlwcvvu";"6tZm";"da20f600855d7b1c67fff91a8befd1ef700fbe96")
          *sec_ch_ua
          *sec_fetch_empty_cors_same_origin
          *user_agent
        '
      }

      _host() {
        echo '"profilereports.quora.com"'
      }

      _path() {
        echo '"/graphql/gql_POST?q=UniversalComposerModalWrapper_postAdd_Mutation"'
      }

      _requires() {
        _ju o 'body:["profile_report_contents"]' 'headers:["lib"]'
      }

      dispatch "$@"
    }

    _mutation_post_add() {

      _host() {
        jq -nc --arg host "${HOST:-profilereports.quora.com}" '$host'
      }

      _path() {
        echo '"/graphql/gql_POST?q=UniversalComposerModalWrapper_postAdd_Mutation"'
      }

      _body() {
        echo '
          {
            "queryName": "UniversalComposerModalWrapper_postAdd_Mutation",
            "extensions": {
              "hash": "7d9cf9a9e5bb12d37a02fe1ec7cd983198467d2c75ec61e304024f1ce4f6840b"
            },
            "variables": {
              "tribeId": (.tribeId//2841204),
              "title": (.title|tojson),
              "content": (.content|tojson),
              "shouldQueue": (.shouldQueue//true),
              "accessOption": null,
              "credentialId": null
            }
          }
        '
      }

      _headers() {
        echo '
          accept
          *content_type_json
          *origin
          *quora("main-w-chan49-8888";"react_eutcerodozlwcvvu";"6tZm";"da20f600855d7b1c67fff91a8befd1ef700fbe96")
          *sec_ch_ua
          *sec_fetch_empty_cors_same_origin
          *user_agent
        '
      }

      _requires() {
        _ju o 'headers:["lib"]'
      }

      dispatch "$@"
    }

    # /graphql/gql_POST?q=UserMute_userMute_Mutation
    _mutation_user_mute() {
      _body() {
        echo '{
          "queryName": "UserMute_userMute_Mutation",
          "extensions": {
            "hash": "c8f2533d8e1ad8fbdf8a33f9bc4ac45498c7363d04320722909a36a343b82cf8"
          },
          "variables": {
            "uid": .uid
          }
        }'
      }

      _headers() {
        echo '
          accept
          *content_type_json
          *origin
          *quora("ain-w-chan50-8888";"react_kudnreowtdanpzoc";"Gj7m";"906b08c33432ec92a44754fc91a61a035a43a5e0")
          *sec_ch_ua
          *sec_fetch_empty_cors_same_origin
          *user_agent
        '
        :
      }

      _path() {
        echo '"/graphql/gql_POST?q=UserMute_userMute_Mutation"'
      }

      _requires() {
        echo '{"headers":["lib"]}'
      }

      dispatch "$@"
    }

    #/graphql/gql_POST?q=userBlockModalInnerUtils_userSetBlock_Mutation
    _mutation_user_block() {
      _body() {
        echo '{
          "queryName": "userBlockModalInnerUtils_userSetBlock_Mutation",
          "extensions": {
            "hash": "fc7232c06fc858107eba5ff2469a96639fc5834eb503cb2d1db2793e89770527"
          },
          "variables": {
            "targetUid": .uid,
            "shouldBlock": (.shouldBlock//true)
          }
        }'
      }

      _headers() {
        echo '
          accept
          *content_type_json
          *origin
          *quora("main-w-chan52-8888";"react_rprdkoatidvglkuq";"kvXJ";"e5a157d98f80bfc3ee6d4b7638a56c30fa3bacc4")
          *sec_ch_ua
          *sec_fetch_empty_cors_same_origin
          *user_agent
        '
        :
      }

      _path() {
        echo '"/graphql/gql_POST?q=userBlockModalInnerUtils_userSetBlock_Mutation"'
      }

      _requires() {
        echo '{"headers":["lib"]}'
      }
      dispatch "$@"
    }

    #/graphql/gql_POST?q=ReportModalInner_reportAdd_Mutation
    _mutation_report_add() {
      _body() {
        echo '{
          "queryName": "ReportModalInner_reportAdd_Mutation",
          "extensions": {
            "hash": "1bf4debbc6131b3aff1ccd9ecf80b819330de1d1c789ced91eece410a68ba9a4"
          },
          "variables": {
            "reason": "spam",
            "targetType": "user",
            "reportableId": .uid,
            "comment": {
              "sections": [
                {
                  "type": "plain",
                  "indent": 0,
                  "quoted": false,
                  "is_rtl": false,
                  "spans": [
                    {
                      "modifiers": {},
                      "text": .message
                    }
                  ]
                }
              ],
              "caret": {
                "start": {
                  "spanIdx": 0,
                  "sectionIdx": 0,
                  "offset": 59
                },
                "end": {
                  "spanIdx": 0,
                  "sectionIdx": 0,
                  "offset": 59
                }
              }
            }
          }
        }|.variables.comment|=tojson'
      }

      _headers() {
        echo '
          accept
          *content_type_json
          *origin
          *quora("main-w-chan49-8888";"eact_wkdwbuxkvtsoehvq";"Z01a";"2c343221d5d11fd67f13b8ca8a09586831ccaba8")
          *sec_ch_ua
          *sec_fetch_empty_cors_same_origin
          *user_agent
        '
      }

      _path() {
        echo '"/graphql/gql_POST?q=ReportModalInner_reportAdd_Mutation"'
      }

      _requires() {
        echo '{"headers":["lib"]}'
      }

      dispatch "$@"

    }

    _profile() {
      _path() {
        echo '"/profile/"+(.profileUrl|@uri)'
      }

      _headers() {
        echo '
          accept
          *cache_control_max_age_0
          *sec_ch_ua
          *sec_fetch_document_navigate_same_origin
          *upgrade_insecure_requests
          *user_agent
        '
      }

      _requires() {
        echo '{"headers":["lib"]}'
      }

      dispatch "$@"
    }

    _profile_report_contents() {
      _body() {
        echo '
          .activity as $activity
          |.others as $others
          |{
            "sections": [
              {
                "type": "plain",
                "indent": 0,
                "quoted": false,
                "is_rtl": false,
                "spans": [
                  {
                    "modifiers": {},
                    "text": "This "
                  },
                  {
                    "modifiers": {
                      "link": {
                        "type": "url",
                        "url": "https://www.quora.com\($activity.profileUrl)"
                      }
                    },
                    "text": "profile"
                  },
                  {
                    "modifiers": {},
                    "text": " generated up to \($activity.upvotes.count) upvotes at a rate of up to \($activity.upvotes.rate_per_hour) upvotes per hour. For example:"
                  }
                ]
              },
              {
                "type": "unordered-list",
                "indent": 0,
                "quoted": false,
                "is_rtl": false,
                "spans": [
                  {
                    "modifiers": {
                      "link": {
                        "type": "url",
                        "url": "https://www.quora.com\($activity.upvotes.first.url)"
                      }
                    },
                    "text": "\($activity.upvotes.first.timestamp) - #1"
                  }
                ]
              },
              {
                "type": "unordered-list",
                "indent": 0,
                "quoted": false,
                "is_rtl": false,
                "spans": [
                  {
                    "modifiers": {
                      "link": {
                        "type": "url",
                        "url": "https://www.quora.com\($activity.upvotes.last.url)"
                      }
                    },
                    "text": "\($activity.upvotes.last.timestamp) - #\($activity.upvotes.count|tostring)"
                  }
                ]
              },
              {
                "type": "plain",
                "indent": 0,
                "quoted": false,
                "is_rtl": false,
                "spans": [
                  {
                    "modifiers": {},
                    "text": "In addition to this user, there at least \($others|length) other similar users currently active, a sample of which are listed below..."
                  }
                ]
              },
              ($others|map({
                "type": "unordered-list",
                "indent": 0,
                "quoted": false,
                "is_rtl": false,
                "spans": [
                  {
                    "modifiers": {
                      "link": {
                        "type": "url",
                        "url": ("https://www.quora.com"+.)
                      }
                    },
                    "text": (.|sub("/profile/";"")),
                  },
                  {
                    "modifiers": {},
                    "text": "\n"
                  }
                ]
                }))
              ]|flatten,
            "caret": {
              "start": {
                "spanIdx": 0,
                "sectionIdx": 0,
                "offset": 12
              },
              "end": {
                "spanIdx": 0,
                "sectionIdx": 0,
                "offset": 12
              }
            }
          }
        '
      }

      dispatch "$@"

    }

    # "/graphql/gql_para_POST?q=UserProfileActivity_feedStories_Query"
    _query_activity() {
      _body() {
        echo '
          {
            "queryName": "UserProfileActivity_feedStories_Query",
            "extensions": {
              "hash": "b3ec746645150c155aa601c727d305812f83ee56365bed740487ff58358c3814"
            },
            "variables": {
              "uid": .uid,
              "first": .first,
              "after": (.after|tostring)
            }
          }
        '
      }

      _headers() {
        echo '
          accept
          *content_type_json
          *origin
          *quora("main-w-chan50-8888";"react_gvkeyzfhoyeeovpl";"bvTC";"6f83bc46e0b270f21d00421c8be3cf5d978036f3")
          *sec_ch_ua
          *sec_fetch_empty_cors_same_origin
          *user_agent
        '
      }

      _path() {
        echo '"/graphql/gql_para_POST?q=UserProfileActivity_feedStories_Query"'
      }

      _requires() {
        echo '{"headers": ["lib"]}'
      }

      dispatch "$@"
    }

    _query_shares() {

      _host() {
        jq -nc --arg "host" "${HOST:-www.quora.com}" '$host'
      }

      _body() {
        echo '
          {
            "queryName": "SharePostsPagedListQuery",
            "extensions": {
              "hash": "ad3fdfef026be57dc1f334e6c00638d4ed7b7037149990a3ffb33b0c37d4cd3c"
            },
            "variables": {
              "nodeId": .nodeId,
              "first": .first,
              "after": (.after|tostring)
            }
          }
        '
      }

      _headers() {
        echo '
          accept
          *content_type_json
          *origin
          *quora("main-w-chan49-8888";"react_klvmidphlajzcwqe";"FdjV";"f4c2c2ff6b34f3f0dcd5d8a71b45003d84e1633d")
          *sec_ch_ua
          *sec_fetch_empty_cors_same_origin
          *user_agent
        '
      }

      _path() {
        echo '"/graphql/gql_para_POST?q=SharePostsPagedListQuery"'
      }

      _requires() {
        echo '{"headers": ["lib"]}'
      }

      dispatch "$@"
    }

    _upvotes() {
      _headers() {
        echo '
          accept
          *cache_control_max_age_0
          *sec_ch_ua
          *sec_fetch_document_navigate_same_origin
          *upgrade_insecure_requests
          *user_agent
        '
      }

      _path() {
        echo '"/notifications/upvotes"'
      }

      _requires() {
        echo '{"headers":["lib"]}'
      }

      dispatch "$@"
    }

    dispatch "$@"
  }

  local template=$1
  local part=$2

  dispatch templates "$template" "$part"
}

# explodes template
_explode() {
  EXPLODEABLE=${EXPLODEABLE:-_explodeable}

  _exec() {
    local use_stdin=false
    if test "$1" = "--stdin"; then
      use_stdin=true
      shift 1
    fi
    local template=$(dispatch part "$@")
    if $use_stdin; then
      jq -c "$template"
    else
      jq -nc "$template"
    fi
  }

  _part() {
    local part=$1
    local template=$2

    for r in $(_explode requires "$part" "$template" | tsort); do
      echo "def $r:"
      ${EXPLODEABLE} "$r" "$part" | sed "s/^/  /"
      echo ";"
    done | _filter jqc
    echo $template
  }

  _requires() {
    local part=$1
    local template=$2
    local dependency

    ($EXPLODEABLE "$template" requires) \
    | jq -r --arg part "$part" '(.[$part]//[])|.[]' \
    | tr ' ' \\012 \
    | while read dependency; do
      (_explode requires "$part" "$dependency" )
      echo "$dependency" "$template"
    done
    echo "$template" "$template"
  }

  cmd=$1
  case "$cmd" in
    exec|requires|part)
      :
    ;;
    *)
      set -- part "$@"
    ;;
  esac

  dispatch "$@"
}

__to() {
  _curl-args() {
    jq -r '
      if type=="object" then
        to_entries[]|"-H\t"+.key+": "+.value
      elif type=="array" then
        .|join("\t")
      else
        .
      end' | tr \\012 \\011 | sed "s/.\$//"
  }
  dispatch "$@"
}

_to() {
  __to "$@"
}

_usage() {
    cat 1>&2 <<EOF
$(basename ${BASH_SOURCE[0]}) cmd args...
$(_help | sed "s/^/   /")
EOF
}

_version() {
  echo "${QUORA_SPAM_VERSION}"
}

_credentials >/dev/null

if test $# -eq 0; then
  set -- usage
fi
dispatch "$@"