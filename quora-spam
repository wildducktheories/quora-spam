#!/bin/bash

export QUORA_SPAM_VERSION=v1.4-pre
export QUORA_DOTFILES=${QUORA_DOTFILES:-~/.quora-spam}

die() {
    echo -e "fatal: $*" 1>&2
    exit ${DIE_RC:-1}
}

dispatch () {
    local cmd=$1
    shift 1
    set -- "_$cmd" "$@"
    "$@"
}

_apply-template() {
  set +x
  local selector="$*"
  selector=${selector// /_}
  selector=${selector//-/_}
  jq "$(_template "$@") $selector"
#  jq "$(_template "$@")"
}

_credentials() {
    if test -z "$QUORA_CREDENTIALS"; then
      export QUORA_CREDENTIALS=$(test -f "$QUORA_DOTFILES/credentials" && cat "$QUORA_DOTFILES/credentials")
    fi
    echo "$QUORA_CREDENTIALS"
}

_submit-credentials() {
  if test -f "${QUORA_DOTFILES}/submit-credentials"; then
    cat "${QUORA_DOTFILES}/submit-credentials"
  else
    _credentials
  fi
}

_config() {
  _require dotfiles

  _get() {
    local key=$1
    jq -r --arg key "$key" '.[$key]' < ${QUORA_DOTFILES}/config
  }

  _set() {
    local update
    update=$(_ju o "$@") || die "usage: config set: key:value"
    jq -s ".[0]*$update" \
      < "${QUORA_DOTFILES}/config" \
      > "${QUORA_DOTFILES}/config.new" &&
    mv "${QUORA_DOTFILES}/config.new" "${QUORA_DOTFILES}/config"
  }

  _() {
    jq . "${QUORA_DOTFILES}/config"
  }

  dispatch "$@"
}

_curl() {
    local o="$(_ju o "$@")"

    local credentials=$(_credentials)
    test -n "$credentials" || die "not logged in"

    eval "$(echo "$o" | _ju pipe 'select host,method,path,data,headers,args|to env')"

    case "$method" in
      GET)
        credentials=$(jq -n "$credentials"'|{"cookie": .cookie}')
      ;;
      *)
        :
      ;;
    esac

    (
      IFS=$'\t'
      set -- \
        --compressed \
        -s \
        $(
          (
              echo "$args";
              echo "$headers";
              echo "$credentials";
          ) | __to curl-args
        )
      if test -n "$data"; then
        set -- "$@" --data-raw "$data"
      fi
      host=${host:-www.quora.com}
      curl "$@" "https://$host$path"
    )
}

_file-profile-report() {
  local profile=${1#/profile/}

  local is_enabled=$(_config get enable-submit)

  if test "$is_enabled" = "true"; then
    local uid=$(_query uid $profile)
    test -n "$uid" || die "file-profile-report: usage: ... {profileUrl}"
    content=$(jq -n \
      --argjson "activity" "$(
        quora-spam query activity-summary $uid
      )" \
      --argjson "others" "$(
          quora-spam query sweet-hot-girls | jq -sc --arg 'profile' "$profile" 'map(.profileUrl|select(.|contains($profile)|not))'
      )" \
      '{"activity": $activity, "others": $others}' \
      | quora-spam apply-template report sweet-hot-girls \
      | jq -c
    )
    host=profilereports.quora.com
    title="profile: ($profile, $uid)"
    body=$(_ju o "title:$title" "content:$content" | _apply-template report profile-report | jq -c .)
    path='/graphql/gql_POST?q=UniversalComposerModalWrapper_postAdd_Mutation'
    headers=$(_template headers "$path")

    (
      QUORA_CREDENTIALS=$(_submit-credentials) _curl \
        host:$host \
        method:POST \
        path:"$path" \
        headers:"$headers" \
        data:"$body" >/dev/null

      _ju o uid:$uid
   )
  else
    echo "warn: profile report not submitted. run 'quora-spam config set enable-submit:true' to enable" 1>&2
  fi
}

_filter() {

    _activity-summary() {
      jq '
        .data.user.activityConnection.edges[].node as $node
        |$node.feedReason
        |select(.__isFeedReason=="UserUpvotedAnswerReason")
        |.uid=.userNames[0].uid
        |.timestamp|=(./1000000|round|todateiso8601)
        |.profileUrl=.userNames[0].profileUrl
        |.text=($node.answer.question.title|fromjson|.sections[]|.spans[0].text)
      ' \
      | ju select 'uid,url,text,timestamp,profileUrl'
    }

    _html() {
        grep "window.ansFrontendGlobals.data.inlineQueryResults.results" \
        | tail -1 \
        | sed "s/;\$//" \
        | sed "s/^[^=]*= //" \
        | jq -r .
    }

    _simple-notifications() {
      jq -c '
          .data.viewer.sentNotifCollectionsConnection.edges[].node
          |{
              "sncid": .sncid,
              "uid": (.responsibleUser.uid|tostring),
              "profileUrl": .userImageUser.profileUrl,
              "isSpam": false,
              "isRead": .isRead
          }'
    }

    _simple-profiles() {
        jq -c . \
        | while read profile; do
            eval "$(echo "$profile" | _ju pipe 'select profileUrl|to env')"
            jq -cs ".[0]*.[1]" <(echo "$profile") <(_query simple-profile "$profileUrl");
        done
    }

    # converts a full profile into a simple profile
    _full-to-simple-profile() {
      jq -c '{
        "uid": .data.user.uid,
        "profileUrl":.data.user.profileUrl,
        "isBlockedByViewer": .data.user.isBlockedByViewer,
        "viewerHasMuted": .data.user.viewerHasMuted,
        "isSpam": false,
        "links": [
            .data.user.descriptionQtextDocument.legacyJson.sections[].spans[]
            |select(.modifiers.link!=null)|{"text":.text, "url":.modifiers.link.url}
         ]
      }|.isSpammyUrl=(
          .links
          |any(
               (  .text as $text
                  |(
                      (.url|startswith("http"))
                      and (.url|startswith("https://www.quora.com")|not)
                      and (.url|contains($text)|not)
                  )
               )
          )
      )'
    }

    _sweet-hot-girls() {
        jq -c 'select(
          .links
          |any(
            (.text|startswith("sweethot"))
            or (.text|contains("hotgirls"))
            or (.text|startswith("hot"))
            or (.url|contains("applycisra.com"))
          )
        )|.isSpam=true'
    }

    dispatch "$@"
}

_har() {

  _credentials() {
    _raw-headers | \
    jq -c '
      [to_entries[]
      |.value
      |with_entries(
        select(
          .key=="cookie"
          or .key=="quora-formkey"
        )
      )][-1]
    '
  }

  _raw-headers() {
    jq '
      [
        .log.entries[].request
        |select(.url|contains("quora.com/"))
        |
          [.headers[]|.key=.name]
          |from_entries
          |.[":path"] as $path
          |select($path != null) as $headers
        |{
            "key": $path,
            "value": $headers
        }
      ]
      |from_entries'
  }

  _headers() {
    _raw-headers | \
    jq '
      with_entries(
        .value
        |=with_entries(
          if
            (.key|startswith(":"))
            or (.key=="content-length")
            or (.key=="referer")
            or (.key=="cookie")
            or (.key=="quora-formkey")
          then
            empty
          else
            .
          end
        )
      )'
  }

  _bodies() {
    jq '
      [
        .log.entries[].request
        |select(.url|contains("quora.com/"))
        |([.headers[]|.key=.name]|from_entries) as $headers
        |$headers[":path"] as $path
        |select($path!=null)
        |select($path|ascii_downcase|contains("facebook")|not)
        |select(.postData.mimeType=="application/json")
        |(.postData.text|fromjson) as $body
        |{
            "key": $path,
            "value": $body
        }
      ]
      |from_entries'
  }

  _save() {
    local selector=$1
    (
      umask 077
      _require dotfiles
      case "$selector" in
        (submit-credentials)
            _credentials > $QUORA_DOTFILES/submit-credentials
        ;;
        ("")
          (
            cat > ${QUORA_DOTFILES}/har &&
            _headers< $QUORA_DOTFILES/har > $QUORA_DOTFILES/headers &&
            _bodies < $QUORA_DOTFILES/har > $QUORA_DOTFILES/bodies &&
            _credentials < $QUORA_DOTFILES/har > $QUORA_DOTFILES/credentials
          )
        ;;
      esac
    ) || exit $?
  }

  dispatch "$@"
}

_help() {
  grep "^ *_[^ ]*(" quora-spam | tr -d '(){' | sed "s/ *\$//" | sed 's/\( *\)_/\1/'
}

_install() {
  pre_reqs="jq curl make docker"
  _Darwin() {
    set --
    for c in $pre_reqs; do
      if !command -v $c >/dev/null 2>&1; then
        set -- "$@" "$c"
      fi
    done
    if test $# -gt 0; then
      brew install "$@"
    fi
  }

  _default() {
    _pre-reqs() {
      rc=0
      for c in $pre_reqs; do
        if ! command -v "$c" >/dev/null 2>&1; then
          echo "please install $c" 1>&2
        fi
      done
      test $rc -eq 0 || die "some pre-requisites missing"
    }
  }

  if test -z "$1"; then
    set -- "pre-reqs" "$@"
  fi

  cmd=$(uname)
  if test "$(type -t _$cmd)" != "function"; then
    cmd=default
  fi
  dispatch "$cmd" "$@"
}

_login() {
  local selector=$1
  case "$selector" in
    (submit)
      local credentials=$(_submit-credentials)
      if test -z "$credentials"; then
        die "not logged in\n\nrun:\n\n  'pbpaste | $(basename ${BASH_SOURCE[0]}) har save submit-credentials'\n\nor:\n\n  '$(basename ${BASH_SOURCE[0]}) har save submit-credentials < saved.har'\n\nwith the contents of a web browser HAR file to extract credentials.\n" 1>&2
      fi
    ;;
    ("")
      local credentials=$(_credentials)
      if test -z "$credentials"; then
        die "not logged in\n\nrun:\n\n  'pbpaste | $(basename ${BASH_SOURCE[0]}) har save'\n\nor:\n\n  '$(basename ${BASH_SOURCE[0]}) har save < saved.har'\n\nwith the contents of a web browser HAR file to extract credentials.\n" 1>&2
      fi
    ;;
  esac
  echo "starting quora-spam (qs) shell. exit to logout" 1>&2
  (_shell)
  local rc=$?
  _logout $selector
  echo "logged out." 1>&2
  return $rc
}

_logout() {
  local selector=$1
  if test -d ${QUORA_DOTFILES}; then
    case "$selector" in
      (submit)
          rm -f "${QUORA_DOTFILES}/submit-credentials"
      ;;
      ("")
          rm -f "${QUORA_DOTFILES}/credentials"
          rm -f "${QUORA_DOTFILES}/har"
          rm -f "${QUORA_DOTFILES}/headers"
          rm -f "${QUORA_DOTFILES}/bodies"
          rm -f "${QUORA_DOTFILES}/self"
      ;;
    esac
  fi
}

_loop() {
    LOOP_DELAY=${LOOP_DELAY:-900}
    while true; do
      echo "$(date)...processing..." 1>&2
      dispatch "$@"
      echo -n "$(date)...sleeping..." 1>&2
      sleep $LOOP_DELAY
      echo "" 1>&2
    done
}


_ju() {
    _from() {
        _keys() {
          local default=${1:-null}
          jq -Rsc --argjson default "$default" '
            rtrimstr("\n")
            |split("\n")
            |[
              .[]|{"key": ., "value": $default}
             ]
            |from_entries'
        }

        dispatch "$@"
      }

      _func() {
        _jsonify()
        {
           echo 'def jsonify: . as $in|try fromjson catch $in;'
        }

        _escape() {
          echo 'def escape: if type == "string" and contains("\n") then tojson else tostring end;'
        }

        dispatch "$@"
      }

      _from() {

        _keys() {
          local default=${1:-null}
          jq -Rsc --argjson default "$default" '
            rtrimstr("\n")
            |split("\n")
            |[
              .[]|{"key": ., "value": $default}
             ]
            |from_entries'
        }

        _ktv() {
          jq -Rc 'split("\t")' \
          | _from unblocked '.next|length==0' '[]' \
          | jq -c "$(_func jsonify)"'
              map(
                map(jsonify)
                |(.[0]|=tostring)
                |{"key":.[0], "value":.[1]}
              )
              |from_entries'
        }

        _tsv() {
          jq -Rsc \
            "$(_func jsonify)"'
             rtrimstr("\n")
             |split("\n")
             |map(split("\t"))
             |.[0] as $header
             |.[1:] as $data
             |$data[]
             |. as $in
             |[
                foreach $header[] as $k
                (0; .+1; {"key": $k, "value": ($in[.-1]|jsonify)})
              ]
             |from_entries'
        }

        _unblocked() {
          local eob=$1
          local eob_value=${2:-null}

          jq -c --argjson eob_value "$eob_value" "def eob: $eob;"'
            {"next": ., "output": []}
            |until(
              eob;
              .output=(.output+[.next])
              |.next=try input catch $eob_value
            )|.output
          '

        }

        dispatch "$@"
    }

    _jsonify() {
       sed 's/^ *//;s/ *\$//' | jq -Rc "$(_func jsonify) jsonify"
    }

    _object() {
        DEFAULT=$(
          while test $# -gt 0; do
            local key_value=$1
            shift
            if test "$key_value" = --; then
              echo "$1"
              return
            fi
          done | _jsonify
        )

        escape() {
          local v="$1"
          if test "${v/$'\n'}" != "$v"; then
            v=$(echo -n "$v" | jq -Rs .)
          fi
          echo "$v"
        }

        local tab=$'\t'

        (while test $# -gt 0; do
          local key_value="$1"
          shift
          if test "$key_value" = --; then
            break
          fi
          key=${key_value%%:*}
          if test "$key" = "$key_value"; then
            value=null
          else
            value=${key_value#*:}
          fi
          echo "$(escape "$key")${tab}$(escape "$value")"
        done; echo "") | _from ktv | jq -c --argjson default "${DEFAULT:-null}" 'with_entries(if .value == null then .value=$default else . end)'

    }

    _o() {
      _object "$@"
    }

    _pipe() {
      local pipe=$1
      pipe=$(echo "$pipe" | sed "s/^ */_/;s/| */|_/g")
      eval "$pipe"
    }

    _select() {
      local selector=$1
      local map=$(jq -nr "$(_selector "$selector")|.[]" | _from keys "$default")
      jq -c --argjson map "$map" '[to_entries[]|select(.key|in($map))]|from_entries'
    }

    _selector() {
      local selector=$1
      if test "${selector#[}" != "$selector"; then
        echo "$selector" | _jsonify | jq -c .
      else
        (
          IFS=,;
          set -- $selector
          while test $# -gt 0; do
            echo "$1"
            shift
          done | _jsonify | jq -sc .
        )
      fi
    }

    _to() {
        _env() {
            jq -r 'to_entries|map(.key+"="+(
              if .value == null then
                ""
              elif (.value|type|(. == "object") or (. == "array"))
              then
                "'\''"+(.value|tojson)+"'\''"
              else
                .value|tojson
              end
              )+";"
            )[]'
        }

        _keys() {
            jq -cr 'select(type == "object")|[to_entries[].key|tostring]|join("\t")'
        }

        dispatch "$@"
    }
    dispatch "$@"
}

_post() {
    _mute() {
        local uid=$1

        local data="$(
          _template body /graphql/gql_POST?q=UserMute_userMute_Mutation | \
          jq -c --argjson uid "$uid" '.variables.uid=$uid'
        )"
        local path='/graphql/gql_POST?q=UserMute_userMute_Mutation'

        _curl \
          method:POST \
          path:"$path" \
          headers:"$(_template headers "$path")" \
          data:"$data" \
          | jq -c --arg uid "$uid" '
                {
                    "uid": $uid,
                    "viewerHasMuted": .data.userMute.user.viewerHasMuted
                }'
    }

    _report() {
        local uid=$1
        shift 1
        message="$*"
        message="${message:-Spammy link in profile.}"

        local path='/graphql/gql_POST?q=ReportModalInner_reportAdd_Mutation'
        local data=$(
          _template body "$path" \
          | jq -c --arg message "$message" --argjson uid "$uid" '
            .variables.comment|=fromjson
            |.variables.comment.sections[0].spans[0].text|=$message
            |.variables.comment|=tojson
            |.variables.reportableId=$uid
        ')
        _curl \
          method:POST \
          path:"$path" \
          headers:"$(_template headers "$path")" \
          data:"$data" \
          | jq -c --arg uid "$uid" '{
               "uid": $uid,
               "isBlockedByViewer": .data.reportAdd.reportable.isBlockedByViewer
          }'
    }

    _markAsRead() {
      local sncid="$1"
      local path='/graphql/gql_POST?q=NotifItem_markSentNotifCollectionAsRead_Mutation'
      local data="$(
        _template body "$path" \
        | jq -c --argjson sncid "$sncid" '
          .variables.sncid=$sncid
      ')"

      _curl \
        method:POST \
        path:"$path" \
        headers:"$(_template headers "$path")" \
        data:"$data" \
        | jq -c --argjson sncid "$sncid" '
        {
            "sncid": $sncid,
            "isRead": .data.markSentNotifCollectionAsRead.sentNotifCollection.isRead
        }'

    }

    _activity() {
      eval "$(jq -s '.[0]*.[1]' <(_ju o first:1 after:998) <(_ju o "$@") | _ju pipe 'select uid,first,after|to env')"
      test -n "$uid" && test -n "$first" && test -n "$after" || die "usage: activity uid:{uid} first:{first} after:{after}"
      local path="/graphql/gql_para_POST?q=UserProfileActivity_feedStories_Query"
      local data=$(
          _template body "$path" \
          | jq \
            -c \
            --argjson uid "$uid" \
            --argjson first "$first" \
            --arg after "$after" '
          .variables.uid=$uid
          |.variables.first=$first
          |.variables.after=$after
      ')

      _curl \
        method:POST \
        path:"$path" \
        headers:"$(_template headers "$path")" \
        data:"$data"
    }

    dispatch "$@"
}

_process() {
    local selector=$1

    test -n "$selector" || die "process {selector}"
    _query "$selector" | _report "$selector"
}

_query() {

    _activity-summary() {
      local uid=$1
      test -n "$uid" || die "usage: activity-summary {uid]"

      end_cursor=$(_post activity uid:$uid first:1 after:998 | jq -r .data.user.activityConnection.pageInfo.endCursor)
      test -n "$end_cursor" || die "query: activity-summary: end_cursor is empty"
      first=$(_post activity uid:$uid first:1 after:$(expr $end_cursor - 1) | _filter activity-summary)
      test -n "$first" || die "query: activity-summary: first is empty"
      last=$(_post activity uid:$uid first:1 after:0  | _filter activity-summary)
      test -n "$last" || die "query: activity-summary: last is empty"

      jq -nc \
        --argjson count "$end_cursor" \
        --argjson first "$first" \
        --argjson last "$last" \
        --argjson uid "$uid" '
      (($last.timestamp|fromdateiso8601)-($first.timestamp|fromdateiso8601)) as $active
      |($count*36000/$active|round|./10) as $rate
      |{
          uid: $uid,
          profileUrl: $first.profileUrl,

          upvotes: {
            count: $count,
            active_seconds: $active,
            active_hours: ($active/360|round|./10),
            rate_per_hour: $rate,
            first: ($first|del(.uid)|del(.profileUrl)),
            last: ($last|del(.uid)|del(.profileUrl))
          }
      }
      '
    }

    _profile() {
        local profile=${1#/profile/}
        _curl \
          method:GET \
          path:"/profile/ $(echo "$profile" | jq -Rr @uri)"\
          headers:"$(_template headers '/profile/$profile')" \
          args:'["-L"]' \
          | _filter html \
          | jq 'select(.data.user.descriptionQtextDocument.legacyJson)|.data.user.descriptionQtextDocument.legacyJson|=fromjson'
    }

    _simple-followers() {
        local profile=$1

        if test -z "$profile"; then
          profile=$(_self | jq -r .profileUrl)
        fi
        profile=${profile#/profile/}

        _curl \
          method:GET \
          path:"/profile/$profile/followers" \
          headers:"$(_template headers '/profile/$profile/followers')" \
        | _filter html \
        | jq '.data.user.followerUsersConnection.edges[]|.node' \
        | _ju select uid,profileUrl,isBlockedByViewer
    }

    _simple-notifications() {
        _upvotes | _filter simple-notifications
    }

    _simple-profile()  {
        local profile=${1#/profile/}
        _profile "$profile" | _filter full-to-simple-profile
    }

    _self() {
        _profile | _filter full-to-simple-profile
    }

    _simple-profiles() {
        _simple-notifications | _filter simple-profiles
    }

    _sweet-hot-girls() {
        _simple-profiles | _filter sweet-hot-girls
    }

    _uid() {
        local profile=${1#/profile/}
        _simple-profile "$profile" | jq -r .uid
    }

    _upvotes() {
        _curl \
          method:GET \
          path:'/notifications/upvotes' \
          headers:"$(_template headers /notifications/upvotes)" \
        | _filter html
    }

    dispatch "$@"
}

_require() {
    _dotfiles() {
      if ! test -d "${QUORA_DOTFILES}"; then
        mkdir -p "${QUORA_DOTFILES}"
        chmod 2700 "${QUORA_DOTFILES}"
      fi
      if ! test -f "${QUORA_DOTFILES}/config"; then
        echo '{
          "enable-submit": false
        }' > "${QUORA_DOTFILES}/config"
      fi
    }

    dispatch "$@"
}

_report() {
    _sweet-hot-girls() {
        while read -r profile; do
            (
                eval "$(echo "$profile" | _ju pipe 'select uid,isBlockedByViewer,viewerHasMuted,isRead,sncid,profileUrl|to env')"
                if test "$isBlockedByViewer+$viewerHasMuted+$isRead" = "true+true+true"; then
                  continue
                fi
                echo "$profile"
                if test "$isRead" = "false"; then
                  _post markAsRead "$sncid"
                fi
                if test "$isBlockedByViewer" = "false"; then
                  _post report "$uid" "Spammy upvote from profile with deceptive sweethotgirls/hotsweetgirls link (sncid:$sncid)" | jq -c .;
                  _file-profile-report "$profileUrl"
                fi
                if test "$viewerHasMuted" = "false"; then
                  _post mute "$uid"
                fi
            ) | jq -cs "select(.[0] != null)|.[0]*(.[1]//{})*(.[2]//{})*(.[3]//{})"
            sleep 5;
        done
   }

   jq -c 'select(.isSpam)' | dispatch "$@"
}

_shell() {
    export PS1="\h:\W \u (qs)\$ "
    ${SHELL:-bash}
}

_template() {
    _headers() {
    jq -c <<EOF
{
  "/graphql/gql_POST?q=NotifItem_markSentNotifCollectionAsRead_Mutation": {
    "accept": "*/*",
    "accept-encoding": "gzip, deflate, br",
    "accept-language": "en-AU,en;q=0.9,en-US;q=0.8",
    "content-type": "application/json",
    "origin": "https://www.quora.com",
    "quora-broadcast-id": "main-w-chan49-8888-react_pxemluvapjrirdhr-UQaz",
    "quora-canary-revision": "false",
    "quora-revision": "b9c9c3eca0656a91bd2c1aa588dcc28495fe1684",
    "quora-window-id": "react_pxemluvapjrirdhr",
    "sec-ch-ua": "\".Not/A)Brand\";v=\"99\", \"Google Chrome\";v=\"103\", \"Chromium\";v=\"103\"",
    "sec-ch-ua-mobile": "?0",
    "sec-ch-ua-platform": "\"macOS\"",
    "sec-fetch-dest": "empty",
    "sec-fetch-mode": "cors",
    "sec-fetch-site": "same-origin",
    "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36"
  },
  "/notifications/upvotes": {
    "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
    "accept-encoding": "gzip, deflate, br",
    "accept-language": "en-AU,en;q=0.9,en-US;q=0.8",
    "cache-control": "max-age=0",
    "sec-ch-ua": "\".Not/A)Brand\";v=\"99\", \"Google Chrome\";v=\"103\", \"Chromium\";v=\"103\"",
    "sec-ch-ua-mobile": "?0",
    "sec-ch-ua-platform": "\"macOS\"",
    "sec-fetch-dest": "document",
    "sec-fetch-mode": "navigate",
    "sec-fetch-site": "same-origin",
    "sec-fetch-user": "?1",
    "upgrade-insecure-requests": "1",
    "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36"
  },
  "/profile/\$profile": {
    "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
    "accept-encoding": "gzip, deflate, br",
    "accept-language": "en-AU,en;q=0.9,en-US;q=0.8",
    "cache-control": "max-age=0",
    "sec-ch-ua": "\".Not/A)Brand\";v=\"99\", \"Google Chrome\";v=\"103\", \"Chromium\";v=\"103\"",
    "sec-ch-ua-mobile": "?0",
    "sec-ch-ua-platform": "\"macOS\"",
    "sec-fetch-dest": "document",
    "sec-fetch-mode": "navigate",
    "sec-fetch-site": "same-origin",
    "sec-fetch-user": "?1",
    "upgrade-insecure-requests": "1",
    "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36"
  },
  "/graphql/gql_POST?q=ReportModalInner_reportAdd_Mutation": {
    "accept": "*/*",
    "accept-encoding": "gzip, deflate, br",
    "accept-language": "en-AU,en;q=0.9,en-US;q=0.8",
    "content-type": "application/json",
    "origin": "https://www.quora.com",
    "quora-broadcast-id": "main-w-chan49-8888-react_wkdwbuxkvtsoehvq-Z01a",
    "quora-canary-revision": "false",
    "quora-revision": "2c343221d5d11fd67f13b8ca8a09586831ccaba8",
    "quora-window-id": "react_wkdwbuxkvtsoehvq",
    "sec-ch-ua": "\".Not/A)Brand\";v=\"99\", \"Google Chrome\";v=\"103\", \"Chromium\";v=\"103\"",
    "sec-ch-ua-mobile": "?0",
    "sec-ch-ua-platform": "\"macOS\"",
    "sec-fetch-dest": "empty",
    "sec-fetch-mode": "cors",
    "sec-fetch-site": "same-origin",
    "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36"
  },
  "/graphql/gql_POST?q=userBlockModalInnerUtils_userSetBlock_Mutation": {
    "accept": "*/*",
    "accept-encoding": "gzip, deflate, br",
    "accept-language": "en-AU,en;q=0.9,en-US;q=0.8",
    "content-type": "application/json",
    "origin": "https://www.quora.com",
    "quora-broadcast-id": "main-w-chan50-8888-react_kudnreowtdanpzoc-Gj7m",
    "quora-canary-revision": "false",
    "quora-revision": "906b08c33432ec92a44754fc91a61a035a43a5e0",
    "quora-window-id": "react_kudnreowtdanpzoc",
    "sec-ch-ua": "\".Not/A)Brand\";v=\"99\", \"Google Chrome\";v=\"103\", \"Chromium\";v=\"103\"",
    "sec-ch-ua-mobile": "?0",
    "sec-ch-ua-platform": "\"macOS\"",
    "sec-fetch-dest": "empty",
    "sec-fetch-mode": "cors",
    "sec-fetch-site": "same-origin",
    "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36"
  },
  "/graphql/gql_POST?q=UserMute_userUnmute_Mutation": {
    "accept": "*/*",
    "accept-encoding": "gzip, deflate, br",
    "accept-language": "en-AU,en;q=0.9,en-US;q=0.8",
    "content-type": "application/json",
    "origin": "https://www.quora.com",
    "quora-broadcast-id": "main-w-chan50-8888-react_kudnreowtdanpzoc-Gj7m",
    "quora-canary-revision": "false",
    "quora-revision": "906b08c33432ec92a44754fc91a61a035a43a5e0",
    "quora-window-id": "react_kudnreowtdanpzoc",
    "sec-ch-ua": "\".Not/A)Brand\";v=\"99\", \"Google Chrome\";v=\"103\", \"Chromium\";v=\"103\"",
    "sec-ch-ua-mobile": "?0",
    "sec-ch-ua-platform": "\"macOS\"",
    "sec-fetch-dest": "empty",
    "sec-fetch-mode": "cors",
    "sec-fetch-site": "same-origin",
    "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36"
  },
  "/graphql/gql_POST?q=UserMute_userMute_Mutation": {
    "accept": "*/*",
    "accept-encoding": "gzip, deflate, br",
    "accept-language": "en-AU,en;q=0.9,en-US;q=0.8",
    "content-type": "application/json",
    "origin": "https://www.quora.com",
    "quora-broadcast-id": "main-w-chan50-8888-react_kudnreowtdanpzoc-Gj7m",
    "quora-canary-revision": "false",
    "quora-revision": "906b08c33432ec92a44754fc91a61a035a43a5e0",
    "quora-window-id": "react_kudnreowtdanpzoc",
    "sec-ch-ua": "\".Not/A)Brand\";v=\"99\", \"Google Chrome\";v=\"103\", \"Chromium\";v=\"103\"",
    "sec-ch-ua-mobile": "?0",
    "sec-ch-ua-platform": "\"macOS\"",
    "sec-fetch-dest": "empty",
    "sec-fetch-mode": "cors",
    "sec-fetch-site": "same-origin",
    "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36"
  },
  "/graphql/gql_para_POST?q=UserProfileActivity_feedStories_Query": {
    "accept": "*/*",
    "accept-encoding": "gzip, deflate, br",
    "accept-language": "en-AU,en;q=0.9,en-US;q=0.8",
    "content-type": "application/json",
    "origin": "https://www.quora.com",
    "quora-broadcast-id": "main-w-chan50-8888-react_gvkeyzfhoyeeovpl-bvTC",
    "quora-canary-revision": "false",
    "quora-revision": "6f83bc46e0b270f21d00421c8be3cf5d978036f3",
    "quora-window-id": "react_gvkeyzfhoyeeovpl",
    "sec-ch-ua": "\".Not/A)Brand\";v=\"99\", \"Google Chrome\";v=\"103\", \"Chromium\";v=\"103\"",
    "sec-ch-ua-mobile": "?0",
    "sec-ch-ua-platform": "\"macOS\"",
    "sec-fetch-dest": "empty",
    "sec-fetch-mode": "cors",
    "sec-fetch-site": "same-origin",
    "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36"
  },
  "/graphql/gql_POST?q=UniversalComposerModalWrapper_postAdd_Mutation": {
    "accept": "*/*",
    "accept-encoding": "gzip, deflate, br",
    "accept-language": "en-AU,en;q=0.9,en-US;q=0.8",
    "content-type": "application/json",
    "origin": "https://profilereports.quora.com",
    "quora-broadcast-id": "main-w-chan49-8888-react_eutcerodozlwcvvu-6tZm",
    "quora-canary-revision": "false",
    "quora-revision": "da20f600855d7b1c67fff91a8befd1ef700fbe96",
    "quora-window-id": "react_eutcerodozlwcvvu",
    "sec-ch-ua": "\".Not/A)Brand\";v=\"99\", \"Google Chrome\";v=\"103\", \"Chromium\";v=\"103\"",
    "sec-ch-ua-mobile": "?0",
    "sec-ch-ua-platform": "\"macOS\"",
    "sec-fetch-dest": "empty",
    "sec-fetch-mode": "cors",
    "sec-fetch-site": "same-origin",
    "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36"
  }
}
EOF

    }

    _body() {
    jq <<EOF
{
  "/graphql/gql_para_POST?q=UserProfileActivity_feedStories_Query": {
    "queryName": "UserProfileActivity_feedStories_Query",
    "extensions": {
      "hash": "b3ec746645150c155aa601c727d305812f83ee56365bed740487ff58358c3814"
    },
    "variables": {
      "uid": null,
      "first": 3,
      "after": "0"
    }
  },
  "/graphql/gql_POST?q=ReportModalInner_reportAdd_Mutation": {
    "queryName": "ReportModalInner_reportAdd_Mutation",
    "extensions": {
      "hash": "1bf4debbc6131b3aff1ccd9ecf80b819330de1d1c789ced91eece410a68ba9a4"
    },
    "variables": {
      "reason": "spam",
      "targetType": "user",
      "reportableId": null,
      "comment": "{\"sections\":[{\"type\":\"plain\",\"indent\":0,\"quoted\":false,\"is_rtl\":false,\"spans\":[{\"modifiers\":{},\"text\":\"\"}]}],\"caret\":{\"start\":{\"spanIdx\":0,\"sectionIdx\":0,\"offset\":59},\"end\":{\"spanIdx\":0,\"sectionIdx\":0,\"offset\":59}}}"
    }
  },
  "/graphql/gql_POST?q=userBlockModalInnerUtils_userSetBlock_Mutation": {
    "queryName": "userBlockModalInnerUtils_userSetBlock_Mutation",
    "extensions": {
      "hash": "fc7232c06fc858107eba5ff2469a96639fc5834eb503cb2d1db2793e89770527"
    },
    "variables": {
      "targetUid": null,
      "shouldBlock": true
    }
  },
  "/graphql/gql_POST?q=UserMute_userUnmute_Mutation": {
    "queryName": "UserMute_userUnmute_Mutation",
    "extensions": {
      "hash": "1ce4545a2324134e189c8d58b835372738c5cb0fbc14e348bac9d69f5c3312bd"
    },
    "variables": {
      "uid": null
    }
  },
  "/graphql/gql_POST?q=UserMute_userMute_Mutation": {
    "queryName": "UserMute_userMute_Mutation",
    "extensions": {
      "hash": "c8f2533d8e1ad8fbdf8a33f9bc4ac45498c7363d04320722909a36a343b82cf8"
    },
    "variables": {
      "uid": null
    }
  },
  "/graphql/gql_POST?q=NotifItem_markSentNotifCollectionAsRead_Mutation": {
    "queryName":"NotifItem_markSentNotifCollectionAsRead_Mutation",
    "extensions":{
      "hash":"9eda4e6d8e46ff1d241f1d4af22bfe664152265aa9693e57d67b9721a32d11bf"
    },
    "variables":{
      "sncid":null,
      "source":"notif_page",
      "shouldLogClick":true
    }
  },
  "/graphql/gql_POST?q=UniversalComposerModalWrapper_postAdd_Mutation": {
    "queryName": "UniversalComposerModalWrapper_postAdd_Mutation",
    "extensions": {
      "hash": "7d9cf9a9e5bb12d37a02fe1ec7cd983198467d2c75ec61e304024f1ce4f6840b"
    },
    "variables": {
      "tribeId": 2841204,
      "title": "{\"sections\":[{\"type\":\"plain\",\"spans\":[{\"text\":\"\",\"modifiers\":{}}],\"indent\":0,\"is_rtl\":false,\"quoted\":false}]}",
      "content": "{\"sections\":[{\"type\":\"plain\",\"indent\":0,\"quoted\":false,\"is_rtl\":false,\"spans\":[{\"modifiers\":{},\"text\":\"test\"}]}]}",
      "shouldQueue": true,
      "accessOption": null,
      "credentialId": null
    }
  }
}
EOF
    }
#
    _report() {
      _profile-report() {
        echo 'def report_profile_report:
{
    "queryName": "UniversalComposerModalWrapper_postAdd_Mutation",
    "extensions": {
      "hash": "7d9cf9a9e5bb12d37a02fe1ec7cd983198467d2c75ec61e304024f1ce4f6840b"
    },
    "variables": {
      "tribeId": 2841204,
      "title": {
        "sections": [
          {
            "type": "plain",
            "spans": [
              {
                "text": .title,
                "modifiers": {}
              }
            ],
            "indent": 0,
            "is_rtl": false,
            "quoted": false
          }
        ]
      }|tojson,
      "content": (.content|tojson),
      "shouldQueue": true,
      "accessOption": null,
      "credentialId": null
    }
  }
        ;
        '
      }

      _sweet-hot-girls() {

        echo 'def report_sweet_hot_girls:
  .activity as $activity
  |.others as $others
  |{
      "sections": [
        {
          "type": "plain",
          "indent": 0,
          "quoted": false,
          "is_rtl": false,
          "spans": [
            {
              "modifiers": {},
              "text": "This "
            },
            {
              "modifiers": {
                "link": {
                  "type": "url",
                  "url": "https://www.quora.com\($activity.profileUrl)"
                }
              },
              "text": "profile"
            },
            {
              "modifiers": {},
              "text": " generated up to \($activity.upvotes.count) upvotes at a rate of up to \($activity.upvotes.rate_per_hour) upvotes per hour. For example:"
            }
          ]
        },
        {
          "type": "unordered-list",
          "indent": 0,
          "quoted": false,
          "is_rtl": false,
          "spans": [
            {
              "modifiers": {
                "link": {
                  "type": "url",
                  "url": "https://www.quora.com\($activity.upvotes.first.url)"
                }
              },
              "text": "\($activity.upvotes.first.timestamp) - #1"
            }
          ]
        },
        {
          "type": "unordered-list",
          "indent": 0,
          "quoted": false,
          "is_rtl": false,
          "spans": [
            {
              "modifiers": {
                "link": {
                  "type": "url",
                  "url": "https://www.quora.com\($activity.upvotes.last.url)"
                }
              },
              "text": "\($activity.upvotes.last.timestamp) - #\($activity.upvotes.count|tostring)"
            }
          ]
        },
        {
          "type": "plain",
          "indent": 0,
          "quoted": false,
          "is_rtl": false,
          "spans": [
            {
              "modifiers": {},
              "text": "In addition to this user, there at least \($others|length) other similar users currently active, a sample of which are listed below..."
            }
          ]
        },
        ($others|map({
          "type": "unordered-list",
          "indent": 0,
          "quoted": false,
          "is_rtl": false,
          "spans": [
            {
              "modifiers": {
                "link": {
                  "type": "url",
                  "url": ("https://www.quora.com"+.)
                }
              },
              "text": (.|sub("/profile/";"")),
            },
            {
              "modifiers": {},
              "text": "\n"
            }
          ]
          }))
      ]|flatten,
    "caret": {
      "start": {
        "spanIdx": 0,
        "sectionIdx": 0,
        "offset": 12
      },
      "end": {
        "spanIdx": 0,
        "sectionIdx": 0,
        "offset": 12
      }
    }
  }
;'
      }

      dispatch "$@"
    }

    local type=$1
    local path=$2

    case "$type" in
      report)
        dispatch "$@"
      ;;
      *)
        set -- jq -r 'to_entries[]|.key';
        test -n "$type" || die "usage: template {type} [{path}]}"

        if test -n "$path"; then
          set -- jq -c --arg path "$path" '.[$path]';
        fi
        dispatch "$type" | "$@"
      ;;
    esac
}

__to() {
    _curl-args() {
      jq -r '
        if type=="object" then
          to_entries[]|"-H\t"+.key+": "+.value
        elif type=="array" then
          .|join("\t")
        else
          .
        end' | tr \\012 \\011 | sed "s/.\$//"
    }
    dispatch "$@"
}

_to() {
  __to "$@"
}

_usage() {
    cat 1>&2 <<EOF
$(basename ${BASH_SOURCE[0]}) cmd args...
$(_help | sed "s/^/   /")
EOF
}

_version() {
  echo "${QUORA_SPAM_VERSION}"
}

_credentials >/dev/null

if test $# -eq 0; then
    set -- usage
fi
dispatch "$@"